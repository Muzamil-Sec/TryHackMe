Today, I developed a deeper understanding of SQL Injection and how SQLMap can be used to identify and exploit SQL vulnerabilities in web applications. I began with reinforcing the core concept of how websites communicate with databases. A database stores user and application data in a structured format. Websites often need to retrieve, modify, or verify user information by sending SQL queries to a database. For example, during login, a web server constructs a query using the submitted username and password, and if they match a record in the database, the authentication succeeds.

The security issue arises when user input is not properly sanitized. If a vulnerable input field is directly placed into an SQL query, attackers can inject malicious code that alters the behavior of the query. This is known as SQL Injection. A classic example is modifying login inputs using SQL logical operators like OR to bypass authentication. The expression "OR 1=1" always evaluates as true, granting access even without valid credentials. The use of comment syntax like "--" helps attackers terminate the intended part of the query and execute their own logic.

After understanding the theory, I moved into the practical application. I worked with a TryHackMe vulnerable web application hosted on a target machine. This website had a login page where input fields communicated using a GET request. Although the parameters were not visible in the URL, I learned how to extract them using browser developer tools. Inspecting the network request allowed me to capture the full URL along with its parameters.

With that complete URL, I used SQLMap from the terminal to automate SQL injection testing. SQLMap evaluates whether parameters are vulnerable and, if they are, provides methods to exploit them. During scanning, I had to answer prompts correctly to focus the testing specifically on MySQL backend payloads. Once SQLMap identified a vulnerable parameter, I proceeded to enumerate the database structure.

I discovered the number of databases present, then explored them in detail. I enumerated database names, inspected available tables, and dumped data fields such as usernames and passwords from the target. This demonstrated how a single insecure input can expose entire user databases, potentially leading to full compromise of an organization’s critical information.

A major takeaway from this exercise is the impact of weak input validation. SQL injection attacks remain one of the most dangerous security flaws because many business‑critical systems are still vulnerable. This emphasizes the importance of secure coding practices, such as using parameterized queries and proper sanitization mechanisms.

Finally, I learned how SQLMap simplifies penetration testing. While SQL injection can be executed manually, SQLMap automates payload crafting, testing, enumeration, and data extraction. Through this exercise, I gained practical experience in ethical exploitation, deepened my knowledge of database interaction, and learned how attackers weaponize SQL injection in real‑world environments. This highlights why defensive countermeasures and continuous security testing are essential to protect data integrity and confidentiality.