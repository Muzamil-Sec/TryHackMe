  Room 1 focused on building a complete foundational understanding of SQL Injection by showing how real-world web applications become vulnerable when user input is trusted without proper server-side validation. The room started by explaining that SQL Injection is not a special hack or tool-based attack but a direct consequence of poor query construction where user input is concatenated into SQL statements. When applications mix data and SQL logic, the database cannot distinguish between them, allowing attackers to manipulate query behavior.

The room emphasized dynamic SQL queries as the root cause of the vulnerability. Applications often need to change queries based on user input, such as login credentials or profile identifiers. Developers commonly achieve this by directly inserting user-supplied values into SQL queries. Without sanitization or parameterization, this approach allows attackers to inject SQL logic instead of simple data, causing the database to execute unintended commands.

A key concept introduced early was the idea of attacker-controlled parameters. Any input field, URL parameter, or POST body value that reaches the SQL query becomes an attack surface. Once an attacker controls a parameter used in a query condition, they can inject logical expressions that change how the WHERE clause is evaluated, often forcing it to always return true.

The room then explored numeric SQL Injection in depth. Numeric inputs are especially dangerous because they are not enclosed in quotes, meaning injected content is treated directly as SQL logic. By supplying payloads like 1 OR 1=1, attackers can bypass authentication checks because the database evaluates the condition as always true. The importance of SQL operator precedence was highlighted, showing how AND and OR affect query evaluation and why commenting out the rest of the query is often required.

SQL comments played a crucial role throughout the room. The MySQL-specific behavior of the double-dash comment syntax was explained in detail, including the requirement for a whitespace character after the second dash. This is why attackers commonly use -- - instead of just --, ensuring the comment is interpreted correctly even after URL encoding.

String-based SQL Injection was introduced as a variation where inputs are enclosed in quotes. In this case, attackers must first break out of the string context by closing the quote before injecting logic. Payloads like 1' OR '1'='1-- - demonstrate how closing the string, injecting a true condition, and commenting out the remaining query can fully bypass authentication.

The room then shifted to delivery methods rather than payload logic. GET-based SQL Injection was demonstrated by injecting malicious input directly through URL parameters. This showed that URLs are simply another input vector and that browsers automatically URL-encode special characters, which the server later decodes before executing the SQL query.

POST-based SQL Injection followed the same principles but required modifying the request body instead of the URL. The room clearly showed that the HTTP method does not change the vulnerability itself. Whether data is sent via GET or POST, if it reaches the SQL query unsafely, it can be exploited in the same way using tools like curl or Burp Suite.

Client-side validation was deliberately shown to be ineffective as a security control. JavaScript-based input restrictions were bypassed easily by sending crafted requests directly to the server. This reinforced the critical lesson that client-side checks only improve user experience and must never be relied upon for security enforcement.

Throughout the room, the learning approach focused on understanding how the database interprets queries rather than memorizing payloads. Boolean logic, true and false conditions, query commenting, and parameter control were repeatedly reinforced so learners could reason through any SQL Injection scenario rather than relying on fixed strings.

The room concluded by reinforcing the real-world impact of SQL Injection. Successful exploitation can lead to authentication bypass, exposure of sensitive data such as salaries and emails, privilege escalation, and full database compromise. The ultimate takeaway was that SQL Injection exists because of unsafe query construction and that proper defenses such as prepared statements, parameterized queries, and strict server-side validation are the only reliable solutions.