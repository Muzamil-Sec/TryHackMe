SQL Injection Attack on an UPDATE Statement represents a critical vulnerability class where malicious actors can manipulate database modification operations rather than just read operations. Unlike SELECT statement injections that primarily enable data theft or authentication bypass, UPDATE injection permits direct alteration of existing records, enabling privilege escalation, unauthorized data modification, or complete system compromise. The severity stems from the fact that web applications frequently use UPDATE statements to handle user profile changes, settings modifications, and content editing, making these functions prime targets when input validation fails. The fundamental risk involves an attacker injecting SQL code through user-controllable fields, transforming a legitimate update operation into a powerful database exploration and exploitation tool.

The practical scenario involves an employee management application featuring an edit profile page where users can modify their personal information. The interface presents a limited subset of database columns that employees are permitted to change, implementing a business logic restriction on accessible fields. However, the backend implementation fails to enforce these restrictions at the database query level, creating a security gap. The form contains input fields such as nickname and email, which map directly to database columns. An attacker can exploit this trusted relationship between form fields and database columns to inject arbitrary SQL payloads that circumvent the intended access controls, potentially affecting not just their own record but others as well.

The injection mechanism relies on the application's construction of dynamic SQL queries using unsanitized user input. When a user submits profile changes, the application typically generates a query structured as UPDATE tablename SET column1='userinput1', column2='userinput2' WHERE condition. The vulnerability emerges because userinput values are placed directly within single quotes without proper escaping or parameterization. By crafting input that includes a closing quote, comma, and additional column assignments, an attacker can append extra SET clauses to the query. The database server interprets this malformed input as legitimate SQL syntax, executing the attacker-injected code with the same privileges as the application database user.

Initial confirmation of the vulnerability begins with a simple payload designed to test both the injection vector and column name accuracy. The test string asd',nickName='test',email='hacked contains three functional components. First, asd' closes the original value assignment for the injected field. Second, ,nickName='test' adds a new column assignment that overrides the previous one. Third, ,email='hacked' introduces another column modification. When this payload is injected into the email field and both the nickname and email fields update in the interface, it provides definitive proof of successful injection. The dual field modification indicates the column names nickName and email are correctly identified and that the application concatenates multiple SET clauses without validation.

The successful test reveals crucial intelligence about the underlying query structure. If the injection fails to modify any fields, it suggests incorrect column names, prompting attackers to attempt alternative guesses derived from the HTML name attributes or common naming conventions. The fact that both fields change confirms the original SQL statement follows a pattern similar to UPDATE table_name SET nickName='value', email='value' WHERE profileID=someid. This knowledge is fundamental because it demonstrates that comma-separated assignments are concatenated directly, enabling attackers to chain multiple malicious assignments within a single field injection. The WHERE clause remains unaffected in this initial test, limiting the scope to the attacker's own record, but subsequent injections can modify this clause.

Understanding the precise database platform is essential for effective exploitation because SQL syntax, system tables, and built-in functions vary significantly across database management systems. The demonstration targets four major platforms: MySQL, Microsoft SQL Server, Oracle, and SQLite. Each platform requires a different query to extract version information. For MySQL and MSSQL, the global variable @@version contains version details. Oracle stores version data in the v$version view, requiring a subquery to extract the banner column. SQLite provides the sqlite_version() function that returns the version string directly. The injection technique remains consistent: closing the original value and assigning the version function output to an updatable column like nickName.

The practical test involves injecting ',nickName=@@version,email=' into the nickname field. For MySQL or MSSQL, this would populate the nickname field with version information. For Oracle, the payload ',nickName=(SELECT banner FROM v$version),email=' achieves the same result. The SQLite-specific payload ',nickName=sqlite_version(),email=' successfully identifies the database as SQLite version 3.27.2 when the nickname field displays the version string. This identification is critical because SQLite uses sqlite_master for metadata queries, supports group_concat for aggregation, and uses double pipe || for string concatenation, all of which differ from other databases.

Table enumeration represents the reconnaissance phase where attackers map the database schema. The payload ',nickName=(SELECT group_concat(tbl_name) FROM sqlite_master WHERE type='table' AND tbl_name NOT LIKE 'sqlite_%'),email=' performs a subquery against SQLite's internal schema repository. The sqlite_master table stores metadata about all database objects. The WHERE clause filters for table type objects while excluding SQLite system tables that begin with sqlite_. The group_concat(tbl_name) function aggregates all matching table names into a single comma-separated string, enabling efficient data exfiltration through a single query result. When injected, this payload reveals that the only user-created table is usertable, though other challenges may contain additional tables.

Column enumeration follows a similar methodology but requires a different query against the sqlite_master table. The payload ',nickName=(SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name='usertable'),email=' retrieves the CREATE TABLE statement for the identified table. The sql column in sqlite_master stores the literal DDL statement used to create each object. By filtering for the specific table name and non-null sql values, the attack extracts the complete column definition. The result displays the table structure: columns include UID, name, profileID, salary, passportNr, email, nickName, and password. This comprehensive column list reveals sensitive fields like salary and passport numbers that were never exposed in the web interface.

Data extraction combines the identified table and column names into a comprehensive dump query. The payload ',nickName=(SELECT group_concat(profileID || "," || name || "," || password || ":") FROM usertable),email=' demonstrates several SQLite-specific functions. The double pipe || operator performs string concatenation, joining multiple column values with delimiters for readability. The group_concat function wraps this concatenation to aggregate all rows into a single result string, preventing multiple query executions. The query selects profileID, name, and password columns, revealing authentication credentials for all users in the database. The colon and comma separators facilitate parsing of the extracted data.

The extracted passwords appear as hexadecimal hashes rather than plaintext, indicating the application employs cryptographic hashing. Hash identification tools like hash-identifier analyze the hash length and character set to determine the algorithm. The 64-character hexadecimal strings correspond to SHA-256 hashes, a widely used cryptographic function producing 256-bit digests represented as 64 hex characters. The demonstration shows using CyberChef, a web-based cryptographic tool, to generate a new SHA-256 hash for a chosen password, enabling the attacker to craft a valid hash for arbitrary plaintext.

The final exploitation phase demonstrates complete account takeover by updating the admin password. The payload ', password='008c70392e3abfbd0fa47bbc2ed96aa99bd49e159727fcba0f2e6abeb3a9d601' WHERE name='Admin'-- - contains multiple malicious components. The initial comma appends a new SET clause for the password column. The SHA-256 hash corresponds to the attacker's chosen password. The WHERE clause modification targets the Admin user instead of the authenticated user. The double hyphen comment sequence -- - comments out the remaining original query, preventing syntax errors from the original WHERE condition. This payload grants the attacker administrative access, demonstrating the ultimate impact of UPDATE injection vulnerabilities.

The Room 2 challenge requires applying these exact techniques to a new instance with different credentials and a hidden flag table. The process involves logging in with profileID 10 and password toor, confirming UPDATE injection capability, identifying the database as SQLite, enumerating tables beyond usertable to locate the flag storage table, extracting its column structure, and retrieving the flag value through concatenated subqueries. The same payloads demonstrated in Room 1 apply directly, requiring only substitution of the identified flag table and column names in the final extraction query.