Room 4 introduces a sophisticated second-order SQL injection vulnerability where the attack payload is stored in the database and executed later when a different query retrieves it. The application implements a notes feature that appears secure at first glance because the INSERT query uses parameterized statements preventing direct injection during note creation. The INSERT INTO notes (username, title, note) VALUES (?, ?, ?) query safely handles user input by separating code from data. However, the developer made a critical error by not applying the same security principle to the SELECT query that retrieves notes. The query SELECT title, note FROM notes WHERE username = '" + username + "' directly concatenates the username retrieved from the session without any sanitization creating a delayed execution vulnerability. The attack progression begins by registering a user with a malicious username that contains a SQL injection payload. When registering the username  ' union select 1,2' the parameterized INSERT query safely stores this string in the database. The exploitation occurs when this user logs in and navigates to the notes page. At this point the application retrieves the stored username and injects it into the vulnerable SELECT query resulting in SELECT title, note FROM notes WHERE username = '' union select 1,2''. The database executes this as two separate SELECT statements concatenated by UNION returning the results of the malicious union query instead of legitimate notes. This reveals that the query expects two columns where the first represents the title and the second represents the note content. To enumerate database structures the attacker registers a user with the payload  ' union select 1,group_concat(tbl_name) from sqlite_master where type='table' and tbl_name not like 'sqlite_%''. Upon visiting the notes page this executes the union query against the system tables and displays all user table names. The payload  ' union select 1,group_concat(password) from users' dumps all password hashes from the users table. The flag resides within these extracted passwords and follows the format THM{SecondOrder} representing the second-order injection technique used. The key lesson is that parameterized queries must be used consistently for all database operations not just for direct user input. Data retrieved from the database should be treated as untrusted and sanitized before use in subsequent queries.

Room 5 presents a different injection vector in the password change functionality where the vulnerability exists in an UPDATE statement. The application allows users to change their passwords through a profile page. The developer correctly parameterized the password input since it comes directly from the user but made an assumption about the username retrieved from the session object. The query UPDATE users SET password = ? WHERE username = '" + username + "' uses a placeholder for the password but directly concatenates the username variable which is fetched from the database based on the user ID stored in the session. This creates a second-order injection opportunity where a malicious username can be stored during registration and later used in the UPDATE query when changing passwords. The exploitation strategy involves registering a user with the exact username admin'-- -. The registration process uses parameterized INSERT INTO users (username, password) VALUES (?, ?) which safely stores this malicious string. When this user logs in and attempts to change their password the application first retrieves the username from the database using the safe SELECT username, password FROM users WHERE id = ? query. It then uses this retrieved username in the vulnerable UPDATE query. The malicious username admin'-- - causes the database to interpret the query as UPDATE users SET password = ? WHERE username = 'admin' -- -' where the double dash comments out the trailing single quote and any subsequent conditions. This results in updating the password for the admin user instead of the malicious user account. After successfully changing the password the attacker can log in as admin with the newly set password and access the flag which appears in the format THM{Update}. This demonstrates that developers must parameterize all user-influenced data regardless of its source whether direct input or retrieved from the database. The assumption that session-derived data is safe is a dangerous misconception that leads to privilege escalation vulnerabilities.

Room 6 introduces a book search function vulnerable to SQL injection through a GET request parameter. The application displays a message directing users to a search page at challenge6/book?title=test. The backend implements a nested query structure: SELECT * from books WHERE id = (SELECT id FROM books WHERE title like '" + title + "%'). The inner SELECT retrieves a book ID based on a title search using the LIKE operator with a trailing wildcard. The outer SELECT then fetches complete book details using that ID. The vulnerability exists because the title parameter is directly concatenated into the LIKE clause without sanitization. The exploitation begins by closing the LIKE operand and injecting a boolean condition. The payload ') or 1=1-- - transforms the query into SELECT * from books WHERE id = (SELECT id FROM books WHERE title like '') or 1=1-- -%'). The closing parenthesis terminates the LIKE condition the OR 1=1 makes the condition always true and the comment removes the remaining wildcard. This returns all books in the database confirming the injection vector. To extract the flag the attacker uses UNION-based injection. The goal is to control the final SELECT statement to return arbitrary data. By injecting a UNION clause that matches the column structure of the books table the attacker can extract sensitive information from other tables including the flag. The payload structure involves first ensuring the inner query returns no results then adding a UNION SELECT that retrieves the desired data. The flag is embedded within the extracted data and appears as THM{B00K5} demonstrating that search functions are common injection points and parameterized queries should be mandatory for all user-controlled parameters including those in GET requests.

Room 7 presents a chained query vulnerability where two sequential SQL queries create a composite attack surface. The application uses a two-step process when searching for books. First it executes SELECT id FROM books WHERE title like '{title}%' to retrieve a book ID. Later it uses this ID in a second query SELECT * FROM books WHERE id = '{bid['id']}'. Both queries directly concatenate user input making them vulnerable but the exploitation is more complex because the second query uses the output of the first. The attacker must control the first query's output to inject into the second query. The technique involves forcing the first query to return zero rows then using UNION to inject a controlled value that becomes the input for the second query. The initial payload ' union select 'STRING'-- - makes the first query return STRING instead of a legitimate ID. The application then passes STRING% to the second query. To prevent the wildcard from interfering the attacker comments it out resulting in SELECT * FROM books WHERE id = 'STRING'-- -%'. However the real exploitation requires more sophisticated quote handling. The payload ' union select '-1''union select 1,2,3,4-- - demonstrates double quote escaping where the first single quote in '-1'' escapes the trailing quote allowing the injection of a second UNION clause into the second query. This creates a scenario where the second query becomes SELECT * FROM books WHERE id = '' union select 1,2,3,4-- -'. The attacker can then replace the numeric values in the second UNION with database enumeration queries to extract table names column names and eventually the flag. The flag appears as THM{UN10N} reflecting the UNION-based injection technique across chained queries. This challenge teaches that vulnerabilities can span multiple queries and that understanding application flow is crucial for successful exploitation. It also highlights the importance of validating and sanitizing data that passes between queries in addition to direct user input.